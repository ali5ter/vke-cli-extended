#!/usr/bin/env bash
# @file vke_wrapper
# To use this wrapper, create an alias:
#     alias vke='./vke_wrapper'
# To ignore this alias, use:
#     \vke ...
# Goals of this wrapper are to:
# 1. Remove need for 'vke folder set' and 'vke project set'
# 2. Translate any stated display name to name
# 3. Infer folder and project name based on object being worked on
# 4. If context or named resource not found, present user with a list to
#    select from.
# 5. Default to latest K8s version when using 'vke cluster upgrade'
#
# BUG GOTCHA: for commands that need a resource name, if one is not supplied,
# this wrapper doesn't yet have a good way to recognise that.
#
# @author Alister Lewis-Bowen <alister@lewis-bowen.org>

if [[ -n $DEBUG ]]; then
    set -x
    vke folder unset
    vke project unset
fi
set -eou pipefail

VKE_FOLDERS=''
VKE_PROJECTS=''
VKE_FOLDER=''
VKE_PROJECT=''
VKE_CLUSTER=''
VKE_OBJ_NAME=''
VKE_VERSION=''
VKE_PASSTHROUGH='n'
VKE_BOLD="$(tput bold)"
VKE_RESET="$(tput sgr0)"
VKE_DUMMY_NAME='n0t-m3nt-t0-b3-f0und'

CMD="$*"

select_object() {
    # Prompt the user for the object they want to use.
    # @param obj_type = folder|project
    local obj_type="$1"
    local objs=''
    local obj_num=''
    local aobjs=''
    local obj_idx=1
    local obj=''

    case "$obj_type" in
        folder) objs="$VKE_FOLDERS";;
        project) objs="$VKE_PROJECTS";;
        cluster) objs="$VKE_CLUSTERS";;
    esac
    obj_num=$(echo "$objs" | wc -l | sed 's/^ *//')

    if [[ -z "$objs" ]]; then
        exit 0
    elif [[ "$obj_num" -eq 1 ]]; then
        obj="$objs"
    else
        SAVEIFS=$IFS
        IFS=$(echo -en "\n\b")
        for obj in $objs; do
            aobjs[$obj_idx]="$obj"
            printf "    %3d ... %s (%s)\\n" "$obj_idx" "${obj#*::}" "${obj%::*}"
            ((obj_idx++))
        done
        REPLY=''
        until [[ "$REPLY" =~ ^-?[0-9]+$ && "$REPLY" -gt 0 && "$REPLY" -lt "(( $obj_num+1 ))" ]]; do
            read -r -p "Select one of these ${obj_type}s [1-$obj_num]: "
            echo
        done
        obj=${aobjs[$REPLY]}
        IFS=$SAVEIFS
    fi
    VKE_OBJ_NAME="${obj%::*}" ## use the 'name' not 'display name'
}

select_folder() {
    # Prompt user for the folder they want to use
    select_object 'folder'
    VKE_FOLDER="$VKE_OBJ_NAME"
}

select_project() {
    # Prompt the user for the project they want to use
    select_object 'project'
    VKE_PROJECT="$VKE_OBJ_NAME"
}

select_cluster() {
    # Prompt the user for the cluster they want to use
    select_object 'cluster'
    VKE_CLUSTER="$VKE_OBJ_NAME"
}

name_of_object() {
    # Find the folder|project|cluster name if the display name used
    # @param obj_type = folder|project|cluster
    # @param aname = name|display name of object
    local obj_type="$1"; shift
    local aname="$*"
    local objs=''
    local name=''
    local dname=''
    local found=1
    [[ "$aname" =~ create|show|rename|delete|get|export|import|add|remove|list ]] && {
        CMD="$CMD $VKE_DUMMY_NAME"
        VKE_RESOURCE_NAME="$VKE_DUMMY_NAME"
        return $found
    }
    case "$obj_type" in
        folder) objs="$VKE_FOLDERS";;
        project) objs="$VKE_PROJECTS";;
        cluster) objs="$VKE_CLUSTERS";;
    esac
    SAVEIFS=$IFS
    IFS=$(echo -en "\n\b")
    for obj in $objs; do
            name="${obj%::*}"
            dname="${obj#*::}"
            if [[ ("$aname" == "$name") || ("$aname" == "$dname") ]]; then
                case "$obj_type" in
                    folder) VKE_FOLDER="$name";;
                    project) VKE_PROJECT="$name";;
                    cluster) VKE_CLUSTER="$name";;
                esac
                found=0
            fi
    done
    IFS=$SAVEIFS
    return "$found"
}

name_of_folder() {
    # Find the folder name if the display name used
    # OR prompt the user for the folder name
    # @param name|display name of folder
    name_of_object 'folder' "$*" || select_folder
}

name_of_project() {
    # Find the project name if the display name used
    # OR prompt the user for the project name
    # @param name|display name of project
    name_of_object 'project' "$*" || select_project
}

name_of_cluster() {
    # Find the cluster name if the display name used
    # OR prompt the user for the cluster name
    # @param name|display name of cluster
    name_of_object 'cluster' "$*" || select_cluster
}

repeat() {
    # Echo a string X number of times
    # @param number of times to repeat string
    # @param the string to repeat
    local times="$1"; shift
    local string="$*"
    printf "%${times}s\n" | sed "s/ /${string}/g"
}

render_policy_tree_level() {
    # Echo a level of the policy tree
    # @param depth level to render
    # @param the policy to render
    local depth="$1"; shift
    local policy=$@
    local roles="$(echo $policy | jq -r '.bindings[].role')"
    local role_total=$(echo "$roles" | wc -l | sed 's/^ *//')
    local role_count=1
    local identities=''
    local identity_total=0
    local identity_count=0
    local prefix=''
    (( depth > 0 )) && prefix=$(repeat $depth '    ')
    (( depth == 0 )) && echo -n '. ' || echo -n "$(repeat $((depth - 1)) '    ')└── "
    echo "${VKE_BOLD}$(echo $policy | jq -r '.name')${VKE_RESET}"
    for role in $roles; do
        (( role_count < role_total )) && echo -n "${prefix}├── " || echo -n "${prefix}└── "
        echo "$role"
        identities=$(echo $policy | jq -r --arg ROLE "$role" '.bindings[] | select(.role == $ROLE) | .subjects[]')
        identity_total=$(echo "$identities" | wc -l | sed 's/^ *//')
        identity_count=1
        for identity in $identities; do
            (( identity_count < identity_total )) && echo -n "${prefix}│   ├── " || echo -n "${prefix}│   └── "
            # echo "${identity#*\\}"
            echo "$identity"
            (( identity_count++ ))
        done
        (( role_count++ ))
    done
}

folder_policy_tree() {
    # Echo the IAM policies of a folder
    local policies=$(vke -o json folder iam show $VKE_FOLDER)
    local direct=$(echo $policies | jq -r '.direct')
    local inherited=$(echo $policies | jq -r '.inherited[]')
    local org_policy=$(echo $inherited | jq -r 'select(.name | contains("tenant"))')
    local folder_policy=$(echo $direct | jq -r 'select(.name | contains("folder"))')
    render_policy_tree_level 0 $org_policy
    render_policy_tree_level 1 $folder_policy
    exit 0
}

project_policy_tree() {
    # Echo the IAM policies of a project
    local policies=$(vke -o json project iam show $VKE_PROJECT)
    local direct=$(echo $policies | jq -r '.direct')
    local inherited=$(echo $policies | jq -r '.inherited[]')
    local org_policy=$(echo $inherited | jq -r 'select(.name | contains("tenant"))')
    local folder_policy=$(echo $inherited | jq -r 'select(.name | contains("folder"))')
    local project_policy=$(echo $direct | jq -r 'select(.name | contains("project"))')
    render_policy_tree_level 0 $org_policy
    render_policy_tree_level 1 $folder_policy
    render_policy_tree_level 2 $project_policy
    exit 0
}

cluster_policy_tree() {
    # Echo the IAM policies of a cluster
    local policies=$(vke -o json cluster iam show $VKE_CLUSTER)
    local direct=$(echo $policies | jq -r '.direct')
    local inherited=$(echo $policies | jq -r '.inherited[]')
    local org_policy=$(echo $inherited | jq -r 'select(.name | contains("tenant"))')
    local folder_policy=$(echo $inherited | jq -r 'select(.name | contains("folder"))')
    local project_policy=$(echo $inherited | jq -r 'select(.name | contains("project"))')
    local cluster_policy=$(echo $direct | jq -r 'select(.name | contains("cluster"))')
    render_policy_tree_level 0 $org_policy
    render_policy_tree_level 1 $folder_policy
    render_policy_tree_level 2 $project_policy
    render_policy_tree_level 3 $cluster_policy
    exit 0
}

infer_cluster_context() {
    # Find the folder and project names using the cluster name
    if [[ ("$VKE_FOLDER" == '') || ("$VKE_PROJECT" == '') ]]; then
        # The context is not stated in the command so check if it is
        # already set
        if (vke folder get | grep -q "No ") || (vke project get | grep -q "No "); then
            # Try to derive the context from the cluster name
            VKE_CLUSTERS=$(vke -o json cluster list | jq -r '.items[] | .name +"::"+ .displayName')
            name_of_cluster "$VKE_RESOURCE_NAME"
            CMD="${CMD/$VKE_RESOURCE_NAME/$VKE_CLUSTER}"
            context=$(vke -o json cluster list | jq -r --arg NAME "$VKE_CLUSTER" '.items[] | select(.name==$NAME) | .folderName +"::"+ .projectName')
            VKE_FOLDER="${context%::*}"
            VKE_PROJECT="${context#*::}"
        else
            if ! vke folder get | grep -q "No "; then
                VKE_FOLDER=$(vke -o json folder get | jq -r '.Name')
            fi
            if ! vke project get | grep -q "No "; then
                VKE_PROJECT=$(vke -o json project get | jq -r '.Name')
            fi
        fi
        vke folder set "$VKE_FOLDER"
        vke project set "$VKE_PROJECT"
    fi
}

infer_project_context() {
    # Find the folder name using the project name
    if [[ "$VKE_FOLDER" == '' ]]; then
        # The context is not stated in the command so check if it is
        # already set
        if vke folder get | grep -q "No "; then 
            # Try to derive the context from the project name
            if [[ -z "$VKE_RESOURCE_NAME" ]]; then
                select_folder
            else
                SAVEIFS=$IFS
                IFS=$(echo -en "\n\b")
                for folder in $VKE_FOLDERS; do
                    VKE_PROJECTS=$(vke -o json project list -f "${folder%::*}" | jq -r '.items[] | .name +"::"+ .displayName')
                    name_of_object 'project' "$VKE_RESOURCE_NAME" && VKE_FOLDER="${folder%::*}" && break
                done
                IFS=$SAVEIFS
            CMD="${CMD/$VKE_RESOURCE_NAME/$VKE_PROJECT}"
            fi
        else
            VKE_FOLDER=$(vke -o json folder get | jq -r '.Name')
        fi
        vke folder set "$VKE_FOLDER"
        vke project set "$VKE_PROJECT"
    fi
}

infer_context() {
    # Check if the folder|project context needs to be set for the vke
    # command based on the given name of the object.
    local context=''
    #set -- "$CMD"
    case "$CMD" in
        'cluster create'* | \
        'cluster show-health'* | \
        'cluster show'* | \
        'cluster rename'* | \
        'cluster delete'* | \
        'cluster upgrade'* | \
        'cluster get-kubectl-auth'* | \
        'cluster merge-kubectl-auth'* | \
        'cluster iam show'* | \
        'cluster iam export'* | \
        'cluster iam import'* | \
        'cluster iam add'* | \
        'cluster iam remove'* | \
        'cluster namespace create'* | \
        'cluster namespace delete'* | \
        'cluster namespace show'* | \
        'cluster namespace list'* | \
        'cluster peering create'* | \
        'cluster peering delete'* | \
        'cluster peering rename'* | \
        'cluster peering show'* | \
        'cluster peering list'*)
            ## note: cluster list works without context being set
            [[ ("$CMD" =~  upgrade) && ( -z "${VKE_VERSION}") ]] && {
                # default to the latest version of K8s
                VKE_VERSION=$(vke -o json cluster versions list -r "$VKE_DEFAULT_REGION" | jq -r '.items[] | select(.isDefault == true) | .version')
                CMD="${CMD% *} -v $VKE_VERSION $VKE_RESOURCE_NAME"
            }
            infer_cluster_context
            name_of_cluster "$VKE_RESOURCE_NAME"
            CMD="${CMD/$VKE_RESOURCE_NAME/$VKE_CLUSTER}"
            if [[ "$CMD" =~ 'iam show' ]]; then cluster_policy_tree; fi
            ;;
        'project create'* | \
        'project delete'* | \
        'project show'* | \
        'project set'* | \
        'project iam show'* | \
        'project iam export'* | \
        'project iam import'* | \
        'project iam add'* | \
        'project iam remove'*)
            infer_project_context
            name_of_project "$VKE_RESOURCE_NAME"
            CMD="${CMD/$VKE_RESOURCE_NAME/$VKE_PROJECT}"
            if [[ "$CMD" =~ 'iam show' ]]; then project_policy_tree; fi
            ;;
        'folder create'* | \
        'folder delete'* | \
        'folder show'* | \
        'folder set'* | \
        'folder iam show'* | \
        'folder iam export'* | \
        'folder iam import'* | \
        'folder iam add'* | \
        'folder iam remove'*)
            name_of_folder "$VKE_RESOURCE_NAME"
            CMD="${CMD/$VKE_RESOURCE_NAME/$VKE_FOLDER}"
            if [[ "$CMD" =~ 'iam show' ]]; then folder_policy_tree; fi
            ;;
    esac
}

set_context() {
    # Check if the folder|project context needs to be set for the vke
    # command. If it is not set, try to infer it or ask the user
    # @param context = folder|project
    local context="$1"
    local name=''
    # Check if context option provided in the command meaning it is already
    # overridden intentionally by the user
    case "$context" in
        folder) name=$VKE_FOLDER;;
        project) name=$VKE_PROJECT;;
        cluster) name=$VKE_CLUSTER;;
    esac
    if [[ "$name" != '' ]]; then
        # Check if this context value needs to be translated from display
        # name to name
        case "$context" in
            folder) name_of_folder "$name";;
            project) name_of_project "$name";;
        esac
    else
        # The context is not stated in the command so check if the command has
        # a context option
        if vke "$CMD" -h | grep -q "\\-\\-$context"; then
            # Since there is a context option, check if it has already been set
            if vke folder get | grep -q "No $context"; then
                # No context is set so ask the user
                ## TODO: Infer the context
                case "$context" in
                    folder)
                        select_folder
                        vke folder set "$VKE_FOLDER"
                        ;;
                    project)
                        select_project
                        vke project set "$VKE_PROJECT"
                        ;;
                esac
            else
                [[ "$context" == 'folder' ]] && VKE_PROJECTS=$(vke -o json project list -f "$VKE_FOLDER" | jq -r '.items[] | .name +"::"+ .displayName')
                [[ "$context" == 'cluster' ]] && VKE_CLUSTER=$(vke -o json cluster list -f "$VKE_FOLDER" -p "$VKE_PROJECT" | jq -r '.items[] | .name +"::"+ .displayName')
            fi
        fi
    fi
}

if [[ $# -gt 0 ]]; then

    ## Prefetch folders

    VKE_FOLDERS=$(vke -o json folder list | jq -r '.items[] | .name +"::"+ .displayName')

    ## Prefetch cluster (since CLI allows you to do this without context)

    VKE_CLUSTERS=$(vke -o json cluster list | jq -r '.items[] | .name +"::"+ .displayName')

    ## Create a default region (the lowest ID)

    VKE_DEFAULT_REGION=$(vke -o json info region list | jq -r -s 'sort_by(.regionId) | .[] | .items[1] | .name')

    ## Rough attempt at guessing the resource name 

    VKE_RESOURCE_NAME="${@: -1}"

    ## Look for existing context (folder & project)

    vke folder get | grep -q "No " || VKE_FOLDER=$(vke -o json folder get | jq -r '.Name')
    vke project get | grep -q "No " || VKE_PROJECT=$(vke -o json project get | jq -r '.Name')


    ## Look for context (folder & project) overrides

    VKE_SUBCOMMAND=''

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -f | --folder )     VKE_FOLDER="$2"; shift; shift ;;
            -p | --project )    VKE_PROJECT="$2"; shift; shift ;;
            cluster )           VKE_SUBCOMMAND='cluster'; shift ;;
            -v | --version )
                ## Since --version has two meanings in the VKE cli...
                if [[ "$VKE_SUBCOMMAND" == 'cluster' ]]; then
                     VKE_VERSION="$2"; shift; shift
                fi
                shift ;;
            -h | --help )       VKE_PASSTHROUGH='y'; shift;;
            * ) shift ;;
        esac
    done

    if [[ "$VKE_PASSTHROUGH" == 'n' ]]; then
        ## Figure out the context (folder & project) for the command

        # # Prompt user for context
        # set_context folder
        # set_context project
        infer_context
    fi
fi

## Pass it on

vke $CMD